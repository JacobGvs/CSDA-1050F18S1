---
title: "Socioeconomics of Pedestrian Accidents"
output: html_notebook
---


Start by loading the various libraries and packages we will be using.

The "Pacman" package will automatically install any packages you do not currently have installed and load the applicable libraries.

```{r message=FALSE, warning=FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(leaflet, sf, shapefiles, rgdal, geojsonio, geojsonR, spdep, maptools, spdplyr, rmapshaper, curl, reticulate, raster, dplyr, gridExtra, tmap, tidyverse, geojsonsf)
```


## Create our Data Tables

#### KSI Pedestrian Dataset

This dataset is a subset of the Killed and Seriously Injured (KSI) dataset collected by the Toronto Police Service from 2008-2018. These events include any serious or fatal collisions where a Pedestrian is involved. To learn more about Pedestrians related collisions in Toronto you can follow this link: http://data.torontopolice.on.ca/pages/pedestrians

We will use the FROM_GeoJson command from the "geojsonR" package to download a json file from the provided URL. The geojson_read command from the "geojsonio" and formating form the "sp" package can then be used to read the json and generate a SpatialPointsDataFrame 
```{r}
ksi_ped <- geojsonio::geojson_read("https://opendata.arcgis.com/datasets/3dedc9bff625450990b8d480f397ad3f_0.geojson", what = "sp")
head(ksi_ped)
```

#### KSI TTC/Municipal Vehicle Dataset

This dataset is a subset of the Killed and Seriously Injured (KSI) dataset collected by the Toronto Police Service from 2008-2018. These events include any serious or fatal collision involving an operator or passenger of a TTC, Transit Vehicle, streetcar or Municipal Vehicle. To learn more about TTC-Municipal Vehicle related collisions in Toronto you can follow this link: http://data.torontopolice.on.ca/pages/ttc-municipal-vehicle

We will use the FROM_GeoJson command from the "geojsonR" package to download a json file from the provided URL. The geojson_read command from the "geojsonio" and formating form the "sp" package can then be used to read the json and generate a SpatialPointsDataFrame 
```{r}
ksi_ttc <- geojsonio::geojson_read("https://opendata.arcgis.com/datasets/dc4751278e604d65b0886b9765d4b551_0.geojson", what = "sp")
head(ksi_ttc)
```

#### Merge KSI_TTC and KSI_Ped

As you will have noticed from the descritpions both the KSI_PED and KSI_TTC datasets are themselves subsets of the Toronto Police Services' KSI Dataset. We downloaded them as seperate dataframes to enable faster downloads as they make up a small portion of the full KSI dataset, which would take significantly more time to download and sort.
Because they come from the same base dataset and have the same schema we can merge them back into one dataframe to work with. We will merge them based on the "Index_" to ensure there are no duplicates created due to the merging process.
```{r}
ksi_merged <- merge(ksi_ped,ksi_ttc, by="Index_")
```


#### Neighbourhood Boundaries - City of Toronto

The City of Toronto also maintains a list that defines the boundaries of all the neighbourhoods in the city. A file containing the spatial data required to map these neighbourhoods can be downloaded form the City of Toronto open data portal. Due to how this file will download, unlike the KSI data, we cannot directly read the GeoJson file but have to download it before the file can be read.
```{r echo=FALSE, message=FALSE, warning=FALSE}
set_wd <- function() {
  library(rstudioapi) # make sure you have it installed
current_path <- getActiveDocumentContext()$path 
setwd(dirname(current_path))
print( getwd() )
}

download.file("https://ckan0.cf.opendata.inter.prod-toronto.ca/download_resource/a083c865-6d60-4d1d-b6c6-b0c8a85f9c15?format=geojson&projection=4326", destfile = "datasets/Neighbourhoods.geojson", )

nbh <- geojsonio::geojson_read("datasets/Neighbourhoods.geojson", what = "sp")

head(nbh)
```

#### Simply Analytics - Census Data

From Simply Analytics i have downloaded shapefiles containing average income by  census track and subdivision. These two shapefiles will usefull in drilling down beyond the neighbourhood.
Both shapefiles can be uploaded into a spatial dataframe using the st_read command from the "sf" package we installed earlier then converting them to a SpatialPolygonsDataFrame.

```{r}
ogrInfo(dsn="datasets/SimplyAnalytics_C1", layer="C1")
ctr <- readOGR(dsn = "datasets/SimplyAnalytics_C1", layer = "C1")
names(ctr@data)[names(ctr@data)=="VALUE0"] <- "Household Total Income After-Tax"
names(ctr@data)[names(ctr@data)=="VALUE1"] <- "Household Aggregate Income"
names(ctr@data)[names(ctr@data)=="VALUE2"] <- "Household Average Income"
head(ctr)
```

```{r}
ogrInfo(dsn="datasets/SimplyAnalytics_C2", layer="C2")
disem <- readOGR(dsn = "datasets/SimplyAnalytics_C2", layer = "C2")
names(disem@data)[names(disem@data)=="VALUE0"] <- "Household Total Income After-Tax"
names(disem@data)[names(disem@data)=="VALUE1"] <- "Household Aggregate Income"
names(disem@data)[names(disem@data)=="VALUE2"] <- "Household Average Income"
summary(disem)
head(disem@data)
```

#### Additional Datatables

One additional datatable may be needed depending on how we choose to cluster the KSI data.
At a high level grouping accidents to a given neighbourhood as defined by the city then using the census data to further cluster by census track and subdivision will be ideal. I may need to pull the Neighbourhood Profiles data set from the city of Toronto to get an average income level by neighbourhood as this does not appear to be avaialble directly from the census datasets.


## Reviewing the Datasets

With our datasets downloaded we can start by looking through the data. Becasue we are dealing almost exclusively with spatial data the easiest way to get a handle on the data is by mapping it.
To do this I will be using features from the "leaflet" package.

#### KSI_merged Dataset

Lets satrt by getting an idea of where accidents are occuring. The leaflet package will map the data for us. To make this more readable I have had the system autocluster the accidents. These clusters don't have any relation to specific neighbourhoods and will need to be adjusted later so that the clusters are in line with our other datasets.
```{r}
leaflet(ksi_merged) %>%
  addTiles() %>%
  addMarkers(lng = ksi_merged$LONGITUDE, lat = ksi_merged$LATITUDE, clusterOptions = markerClusterOptions())
```

This map will allow you to zoom in and the clusters will auto adjust as you zoom in and out. These clusters are based on proximity to a central point. Once you get to the lowest zoom levels, clicking on a cluster will map the individual accidents. Details for each accident are not currenlty included in the mapping.


#### Neighbourhood Boundaries - City of Toronto

Our next dataset contains the boundary lines for various neighbourhoods in Toronto. mapping this will begin to give some dimension to how we intend to cluster accidents going forward.
```{r}
leaflet(nbh) %>%
  addTiles() %>%
  addPolygons()
```

#### Simply Analytics - Census Data

We can similarly plot both the census tract and dissemination area files pulled from Simply Analytics.
```{r}
leaflet(ctr) %>%
  addTiles() %>%
  addPolygons()
```

```{r}
leaflet(disem) %>%
  addTiles() %>%
  addPolygons()
```

Our next step will be to assing each accident in the KSI data to a dissemination area polygon. But before we can do that we will first have to clean up the various datasets.


## Cleaning the Data

Before we begin we need to ensure that our various datasets are compatible.

Using the CRS fuction in the SF package We can check the coordinate reference system being used by our main files and can see that they are all the same.
```{r}
st_crs(ksi_merged)
st_crs(ctr)
st_crs(disem)
st_crs(nbh)
```

We luckily all the files we have downloaded use the same co-ordinate reference system so we will be able to compare and associate them to one another without having to re-project them into a comon co-ordinate system. This is especially convenient given that the mapping package w are using "leaflet" does not support "CRS" one of the other reference systems.

### Cleaning the KSI data

As we review the datasets one thing you may have noticed is that the KSI dataset contains a large number of potenitally duplicate entries.

```{r}
head(ksi_merged@data, 20)
```

While each accident is assigned a different index id number(Index_), in most cases multiple index numbers are assigned to the same account number(ACCNUM). This is because, for each accident, the driver of the vehicle, the pedestrian, and any other applicable individual related to the loss has their information recorded to the dataset. This is most evident if you look at the involved vehicle type (INVTYPE) columns.

Since this review is focused on pedestrian accidents, we will filter our KSI_Merged file to include only instances where the column INVTYPE is a pedestrian.

We can easily identify all unique items in the INVTYPE column and select those that are representative of pedestrians.

```{r}
unique(ksi_merged@data$INVTYPE)
```

```{r}
ksi_modified <- ksi_merged
ksi_modified@data$Index_ <- as.character(ksi_modified@data$Index_)
ksi_modified@data$ACCNUM <- as.character(ksi_modified@data$ACCNUM)
ksi_modified@data$DATE <- as.Date.character(ksi_modified@data$DATE)
ksi_modified@data$TIME <- as.character(ksi_modified@data$TIME)
ksi_modified@data$ROAD_CLASS <- as.character(ksi_modified@data$ROAD_CLASS)
ksi_modified@data$District <- as.character(ksi_modified@data$District)
ksi_modified@data$VISIBILITY <- as.character(ksi_modified@data$VISIBILITY)
ksi_modified@data$LIGHT <- as.character(ksi_modified@data$LIGHT)
ksi_modified@data$RDSFCOND <- as.character(ksi_modified@data$RDSFCOND)
ksi_modified@data$ACCLASS <- as.character(ksi_modified@data$ACCLASS)
ksi_modified@data$IMPACTYPE <- as.character(ksi_modified@data$IMPACTYPE)
ksi_modified@data$INVTYPE <- as.character(ksi_modified@data$INVTYPE)
ksi_modified@data$INVAGE <- as.character(ksi_modified@data$INVAGE)
ksi_modified@data$INJURY <- as.character(ksi_modified@data$INJURY)
ksi_modified@data$INITDIR <- as.character(ksi_modified@data$INITDIR)
ksi_modified@data$PEDTYPE <- as.character(ksi_modified@data$PEDTYPE)
ksi_modified@data$PEDACT <- as.character(ksi_modified@data$PEDACT)
ksi_modified@data$PEDCOND <- as.character(ksi_modified@data$PEDCOND)
ksi_modified@data$PEDESTRIAN <- as.character(ksi_modified@data$PEDESTRIAN)
ksi_modified@data$AUTOMOBILE <- as.character(ksi_modified@data$AUTOMOBILE)
ksi_modified@data$MOTORCYCLE <- as.character(ksi_modified@data$MOTORCYCLE)
ksi_modified@data$TRUCK <- as.character(ksi_modified@data$TRUCK)
ksi_modified@data$EMERG_VEH <- as.character(ksi_modified@data$EMERG_VEH)
ksi_modified@data$SPEEDING <- as.character(ksi_modified@data$SPEEDING)
ksi_modified@data$AG_DRIV <- as.character(ksi_modified@data$AG_DRIV)
ksi_modified@data$REDLIGHT <- as.character(ksi_modified@data$REDLIGHT)
ksi_modified@data$ALCOHOL <- as.character(ksi_modified@data$ALCOHOL)
ksi_modified@data$DISABILITY <- as.character(ksi_modified@data$DISABILITY)


unique(ksi_modified@data$INVTYPE)
```

If we look at our list of options, there are a few different entries we should be considering to be a pedestrian.
For this review we will be filtering out all entries where the INVTYPE is "Pedestrian", "Pedestrian - Not Hit", "In-Line Skater", or "Wheelchair".

So as not to lose our merged dataset, we will also create a new filtered datatable.

```{r}
target <- c("Pedestrian", "Pedestrian - Not Hit", "In-Line Skater", "Wheelchair")
ksi_modified <- ksi_merged[ksi_merged@data$INVTYPE %in% target,]
head(ksi_modified@data, 20)
```

There are also a number of columns that will not be needed for our review and can be removed from our modified dataset.
These include: OFFSET, VEHTYPE, MANOEUVER, DRIVACT, DRIVCOND, CYCLISTYPE, CYCACT, CYCCOND, CYCLIST, TRSN_CITY_VEH, TRSN_CITY_, coords.x1, coords.x2

```{r}
targetc <- c("OFFSET", "VEHTYPE", "MANOEUVER", "DRIVACT", "DRIVCOND", "CYCLISTYPE", "CYCACT", "CYCCOND", "CYCLIST", "TRSN_CITY_VEH", "TRSN_CITY_", "coords.x1", "coords.x2")
ksi_modified <- ksi_modified[,-which(names(ksi_modified@data) %in% c(targetc))]
head(ksi_modified@data, 20)
```

### Cleaning the Toronto Neighbourhood data

Next we will look at the Toronto Neighbourhood dataset.

```{r}
head(nbh@data, 20)
```

We can see that for the most part all columns in this data set are useful. The columns that will not be of use and can be removed are:
  PARENT_AREA_ID - this field containe no unique values
  AREA_LONG_CODE - this is variable is identical to AREA_SHORT_CODE
  AREA_DESC - this is variable is identical to AREA_NAME
  X - this field containe no unique values
  Y - this field containe no unique values

```{r}
unique(nbh@data$PARENT_AREA_ID)
unique(nbh@data$X)
unique(nbh@data$Y)
```

```{r}
targetnbh <- c("PARENT_AREA_ID", "AREA_LONG_CODE", "AREA_DESC", "X", "Y")
nbh_modified <- nbh
nbh_modified <- nbh_modified[,-which(names(nbh_modified@data) %in% c(targetnbh))]
head(nbh_modified@data, 20)
```

### Cleaning the Census Tract and Disemination data

Next we will look at the Toronto Neighbourhood dataset.

```{r}
head(ctr@data, 20)
```

We can see that these have a very minimal number of fields and will not require any adjustmeents prior to proceeding with our review.


## Associating the Datasets

We are interested in associating all our spatial polygon dataframes to the KSI data points that represent each pedestrian related accident.

Our first task will be to join our KSI dataset to a Toronto Neighbourhood.

This can be done using the spatialEco package. The spatialEco::point.in.poly function intersects point and polygon feature classes and adds polygon attributes to points. This function will re-name columns with similar names so we will also address re-naming some of the newly added columns.

```{r}
ksi_coord <- spatialEco::point.in.poly(ksi_modified, nbh_modified)
names(ksi_coord@data)[names(ksi_coord@data)=="LONGITUDE.x"] <- "LONGITUDE"
names(ksi_coord@data)[names(ksi_coord@data)=="LATITUDE.x"] <- "LATITUDE"
names(ksi_coord@data)[names(ksi_coord@data)=="LONGITUDE.y"] <- "LONGITUDE.nbh"
names(ksi_coord@data)[names(ksi_coord@data)=="LATITUDE.y"] <- "LATITUDE.nbh"
head(ksi_coord@data, 20)
```

Next we will add in the disemination area information. Being the most granular this will allow us to accurately associate an average income to each accident.

```{r}
ksi_coord <- spatialEco::point.in.poly(ksi_coord, disem)
head(ksi_coord@data, 20)
```

We now have a data set with average income 

```{r}
library(pvclust)
d <- dist(ksi_coord@data, method = "euclidean")
fit <- hclust(d, method="ward")
plot(fit)
groups <- cutree(fit, k=10)
rect.hclust(fit, k=10, border="red")
```

```{r}
rpart(data=ksi_coord, formula = Index_ ~ Household.Average.Income + spatial_id + AREA_NAME, method="class",control=rpart.control(minsplit=30, cp=0.001)) 
```



```{r}
leaflet(ksi_coord) %>%
  addTiles() %>%
  addCircleMarkers(
    stroke = FALSE, fillOpacity = 0.5,weight = 1,
    label = ~as.character(ksi_coord@data$YEAR, ksi_coord@data$Street1)) %>%
  addPolygons(data = nbh_modified,
              fillColor = "transparent", 
              color = "#000000",
              fillOpacity = 0.8,
              group = "Neighbourhood", 
              weight = 2) %>%
  addPolygons(data = ctr,
              fillColor = "transparent", 
              color = "#000000",
              fillOpacity = 0.8,
              group = "Census Tract", 
              weight = .8) %>%
  addPolygons(data = disem,
              fillColor = "transparent", 
              color = "#000000",
              fillOpacity = 0.8,
              group = "Disemination Area", 
              weight = .4) %>%
  addLayersControl(overlayGroups =c("Neighbourhood", "Census Tract", "Disemination Area"),
                   options = layersControlOptions(collapsed=FALSE)) %>%
  addLegend(data = disem,
            values  = disem@data$`Household Average Income`,
            color = ~qpal("viridis"),
            position = "bottomright",
            title = "City Wide Household Average Income",
            labFormat = labelFormat(digits=1))
```




### This binds the disemination and census tract polygons together but does not relate one to another. Need to relate the disemination areas to a census tract.
```{r}
ctrdisem <-bind(disem, ctr)
leaflet(ctrdisem) %>%
  addTiles() %>%
  addPolygons()
```

```{r}
head(ctrdisem,10)
```


```{r}
plot(ctr, axes=TRUE, las=1)
plot(ctr, border='blue', col='yellow', lwd=3, add=TRUE)
points(ksi_merged, col='red', pch=20, cex=1)
```


```{r}
plot(disem, axes=TRUE, las=1)
plot(disem, border='blue', col='yellow', lwd=3, add=TRUE)
points(ksi_merged, col='red', pch=20, cex=1)
```


```{r}
plot(ctr, axes=TRUE, las=1)
plot(ctr, border='blue', lwd=3, add=TRUE)
plot(disem, border='green', lwd=1, add=TRUE)
points(ksi_merged, col='red', pch=20, cex=.5)
```




```{r}
ksi_coord <- spatialEco::point.in.poly(ksi_modified, ctr)
head(ksi_coord@data)
```



```{r}
head(ctr_df, n=4)
```

```{r}
st_crs(ctr_df)
```


```{r}
library(tmap) 
tm_shape(ctr_df) + tm_polygons(col="grey", border.col="white")
```

```{r}
tm_shape(ctr_df) + tm_polygons(col = "Household Average Income")+
  tm_legend(outside = TRUE) +
  tm_facets( by = "spatial_id", nrow = 5)
```

```{r}
st_crs(ksi_modified)
```

```{r}
ksi_modified_dp <- data.frame(ksi_modified)
class(ksi_modified_dp)
head(ksi_modified_dp, 5)
```


```{r}
nbh_ctr <- bind(nbh, ctr)
plot(nbh, axes=TRUE, las=1)
plot(nbh, border='blue', col='yellow', lwd=3, add=TRUE)
points(ksi_coord, col='red', pch=20, cex=1)
```


```{r}
nbh_ctr2 <- st_union(ctr_df, ctr_df)
head(nbh_ctr2, 5)
```

```{r}
ksi_coord <- spatialEco::point.in.poly(ksi_coord, nbh)
head(ksi_coord@data)
```




Convert Spatial ID in Disem to a character
```{r}
disem@data$spatial_id <- as.character(disem@data$spatial_id)
```

```{r}
map1 <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = disem, fillColor = "yellow", color = "blue", fillOpacity = 0.5, weight = 1, smoothFactor = 0.2) %>%
  addMarkers(data = ksi_merged, lng = ksi_merged$LONGITUDE, lat = ksi_merged$LATITUDE, clusterOptions = markerClusterOptions())
print(map1)
```

```{r}
disem_sf <- st_as_sf(disem)
ctr_sf <- st_as_sf(ctr)
ksi_sf <- st_as_sf(ksi_merged)
nbh_sf <- st_as_sf(nbh)
```

```{r}
disem_sf <- st_transform(ctr, crs, partial = TRUE, check = FALSE, use_gdal = TRUE)
```




```{r possible delete}
ksi_modified@data$Index_ <- as.character(ksi_modified@data$Index_)
ksi_modified@data$ACCNUM <- as.character(ksi_modified@data$ACCNUM)
ksi_modified@data$DATE <- as.Date.character(ksi_modified@data$DATE)
ksi_modified@data$TIME <- as.character(ksi_modified@data$TIME)
ksi_modified@data$ROAD_CLASS <- as.character(ksi_modified@data$ROAD_CLASS)
ksi_modified@data$District <- as.character(ksi_modified@data$District)
ksi_modified@data$VISIBILITY <- as.character(ksi_modified@data$VISIBILITY)
ksi_modified@data$LIGHT <- as.character(ksi_modified@data$LIGHT)
ksi_modified@data$RDSFCOND <- as.character(ksi_modified@data$RDSFCOND)
ksi_modified@data$ACCLASS <- as.character(ksi_modified@data$ACCLASS)
ksi_modified@data$IMPACTYPE <- as.character(ksi_modified@data$IMPACTYPE)
ksi_modified@data$INVTYPE <- as.character(ksi_modified@data$INVTYPE)
ksi_modified@data$INVAGE <- as.character(ksi_modified@data$INVAGE)
ksi_modified@data$INJURY <- as.character(ksi_modified@data$INJURY)
ksi_modified@data$INITDIR <- as.character(ksi_modified@data$INITDIR)
ksi_modified@data$PEDTYPE <- as.character(ksi_modified@data$PEDTYPE)
ksi_modified@data$PEDACT <- as.character(ksi_modified@data$PEDACT)
ksi_modified@data$PEDCOND <- as.character(ksi_modified@data$PEDCOND)
ksi_modified@data$PEDESTRIAN <- as.character(ksi_modified@data$PEDESTRIAN)
ksi_modified@data$AUTOMOBILE <- as.character(ksi_modified@data$AUTOMOBILE)
ksi_modified@data$MOTORCYCLE <- as.character(ksi_modified@data$MOTORCYCLE)
ksi_modified@data$TRUCK <- as.character(ksi_modified@data$TRUCK)
ksi_modified@data$EMERG_VEH <- as.character(ksi_modified@data$EMERG_VEH)
ksi_modified@data$SPEEDING <- as.character(ksi_modified@data$SPEEDING)
ksi_modified@data$AG_DRIV <- as.character(ksi_modified@data$AG_DRIV)
ksi_modified@data$REDLIGHT <- as.character(ksi_modified@data$REDLIGHT)
ksi_modified@data$ALCOHOL <- as.character(ksi_modified@data$ALCOHOL)
ksi_modified@data$DISABILITY <- as.character(ksi_modified@data$DISABILITY)
```
